<p>reducebykeyuse combiner,aggregatebykey, groupbykey(dont use), countBykey


//Aggregation - using actions

val orders = sc.textFile("retail_db/orders")
orders.map(order =&gt; (order.split(",")(3),"")).countByKey.foreach(println)

scala&gt; orders.map(order =&gt; (order.split(",")(3),"")).countByKey.foreach(println)
(PAYMENT_REVIEW,729) 
(CLOSED,7556)
(SUSPECTED_FRAUD,1558)
(PROCESSING,8275)
(COMPLETE,22899)
(PENDING,7610)
(PENDING_PAYMENT,15030)
(ON_HOLD,3798)
(CANCELED,1428)

val orderItems = sc.textFile("retail_db/order_items")
scala&gt; orderItemsRevenue.reduce((total, revenue) =&gt; total + revenue)
res25: Float = 3.4326256E7

val orderItemsRevenue = orderItems.map(oi =&gt;oi.split(",")(4).toFloat)

scala&gt; val orderItemsMaxRevenue = orderItemsRevenue.reduce((max,revenue) =&gt; {
 | if (max &lt; revenue)
 | revenue
 | else
 | max
 | })
orderItemsMaxRevenue: Float = 1999.99


//Aggregation understanding combiners
//groupbykey

1,(1 to 1000) - sum(1 to 1000) =&gt; 1+2+3 +.....1000
reduceByKey and aggregateByKey multiple threads. 1,(1 to 100) - sum( 1,25) sum(26,50) sum(51,75)



val orderItems = sc.textFile("retail_db/order_items")

val orderItemsMap = orderItems.map (oi => (oi.split(",")(1).toInt , oi.split(",")(4).toFloat))

scala> orderItemsMap.take(10).foreach(println)
(1,299.98)
(2,199.99)
(2,250.0)
(2,129.99)
(4,49.98)
(4,299.95)
(4,150.0)
(4,199.92)
(5,299.98)
(5,299.95)


val orderItemsGBK = orderItemsMap.groupByKey
scala> orderItemsGBK.take(10).foreach(println)
(41234,CompactBuffer(109.94))                                                   
(65722,CompactBuffer(119.98, 400.0, 399.98, 199.95, 199.98))
(28730,CompactBuffer(299.95, 50.0))
(68522,CompactBuffer(329.99))
(23776,CompactBuffer(199.99, 129.99))
(32676,CompactBuffer(59.99, 159.96, 299.97, 199.99))
(53926,CompactBuffer(119.98, 99.99))
(4926,CompactBuffer(199.92, 199.99, 239.96, 299.98))
(38926,CompactBuffer(499.95, 250.0, 299.95))
(29270,CompactBuffer(299.95, 119.98, 399.98, 159.96, 399.98))

val l: Iterable[Float] = Iterable(119.98, 400.0, 399.98, 199.95, 199.98)

scala> val l = List(119.98, 400.0, 399.98, 199.95, 199.98)
l: List[Double] = List(119.98, 400.0, 399.98, 199.95, 199.98)


//Get revenue per order_id 

orderItemsGBK.map(rec => (rec._1,rec._2.toList.sum)).take(10).foreach(println)

//Get data in descending order by order_item_subtotal for each order_id

val ordersSortedByRevenue = orderItemsGBK.
    flatMap(rec => {
     rec._2.toList.sortBy(o => -o) .map(k => (rec._1,k))
  })

//Aggregations - ReduceBYKey


val orderItems = sc.textFile("retail_db/order_items")
val orderItemsMap = orderItems.map (oi => (oi.split(",")(1).toInt , oi.split(",")(4).toFloat))
val revenuePerOrderId = orderItemsMap.
reduceByKey((total, revenue ) => total + revenue)


val minRevenuePerOrderId = orderItemsMap.
reduceByKey((min, revenue) => if (min > revenue) revenue else min)

scala> minRevenuePerOrderId.sortByKey().take(10).foreach(println)
(1,299.98)                                                                      
(2,129.99)
(4,49.98)
(5,99.96)
(7,79.95)
(8,50.0)
(9,199.98)
(10,21.99)
(11,49.98)
(12,100.0)

//Aggregations - aggregateByKey

val orderItems = sc.textFile("retail_db/order_items")
val orderItemsMap = orderItems.map (oi => (oi.split(",")(1).toInt , oi.split(",")(4).toFloat))

//(order_id, order_item_subtotal)
val revenueAndMaxPerProductId = orderItemsMap.
aggregateByKey((0.0f, 0.0f))(

   (inter, subtotal ) => (inter._1 +subtotal, if(subtotal > inter._2 ) subtotal else inter._2),
 
   (total, inter) => (total._1 +inter._1, if(total._2 >inter._2) total._2 else inter._2)
)
//(order_id, (order_revenue, max_order_item_subtotal))

